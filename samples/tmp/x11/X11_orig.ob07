MODULE X11;
IMPORT SYSTEM, Out := Out_sys, unix IN "./unix.ob07";

(*
X11 documentation in:
- http://tronche.com/gui/x/xlib/        an X11 reference
- http://www.sbin.org/doc/Xlib          an X11 tutorial (this domain has disappeared)
*)

CONST
	InputOutput = 1;
	StructureNotifyMask = 20000H;  (* input event mask *)
	ExposureMask = 8000H; KeyPressMask = 1; KeyReleaseMask = 2;
	ButtonPressMask = 4; ButtonReleaseMask = 8; (* PointerNotionMask *)
	ZPixmap = 2;
	Expose = 12;  (* X event type *) ConfigureNotify = 22; KeyPress = 2; ButtonPress = 4;

	EventTimeOut* = 80;    (* 0, 0, 0, 0 *)
	EventResize* = 81;    (* 0, w, h, 0 *)
	EventKeyPressed* = 82;    (* isPrintable, keyCode (X11 scan code), state, keySym (ASCII) *)
	EventKeyReleased* = 83;    (* 0, keyCode, state, 0 *)
	EventButtonPressed* = 84;    (* button, x, y, state *)
	EventButtonReleased* = 85;    (* button, x, y, state *)
	(* mouse button 1-5 = Left, Middle, Right, Scroll wheel up, Scroll wheel down *)

	bit64 = 0;

TYPE 
	EventPars* = ARRAY 5 OF INTEGER;
	XEvent = RECORD
		val :ARRAY 192 OF BYTE          (* union { ..., long pad[24]; } *)
	END;
	Window* = INTEGER;
	Display* = INTEGER;
	Pixmap* = INTEGER;
	GC* = INTEGER;

VAR 
	ScreenWidth*, ScreenHeight* :INTEGER;
	winWidth*, winHeight* :INTEGER; (* draw by writing to pixel buffer: *)
	base*, stride* :INTEGER;                (* width, height, base ptr, stride in bytes, 32-bit RGB *)
	painting :BOOLEAN;

	display, screen, window, gc, img :INTEGER;
	connectionNr :INTEGER; (* fd of X11 socket *)
	//readX11 :unix.fd_set;  (* used by select() timeout on X11 socket *)

PROCEDURE [extern, "XOpenDisplay"] XOpenDisplay(name :INTEGER) :INTEGER;
PROCEDURE [extern, "XCloseDisplay"] XCloseDisplay(display :INTEGER);
PROCEDURE [extern, "XSynchronize"] XSynchronize(display, onoff :INTEGER) :INTEGER;  (* return prev onoff *)
PROCEDURE [extern, "XConnectionNumber"] XConnectionNumber(display :INTEGER) :INTEGER;
PROCEDURE [extern, "XCreateWindow"] XCreateWindow(display, parent_window, x, y, w, h, 
	border_width, depth, class, visual, valuemask, attributes :INTEGER) :INTEGER;
PROCEDURE [extern, "XCreateSimpleWindow"] XCreateSimpleWindow(display, parent_window, 
	x, y, w, h: INTEGER; a, b, c: INTEGER) :INTEGER;
PROCEDURE [extern, "XDefaultScreen"] XDefaultScreen(display :INTEGER) :INTEGER;
PROCEDURE [extern, "XDefaultGC"] XDefaultGC(display, screenNr :INTEGER) :INTEGER;  (* GC *)
PROCEDURE [extern, "XDisplayWidth"] XDisplayWidth(display, screenNr :INTEGER) :INTEGER;
PROCEDURE [extern, "XDisplayHeight"] XDisplayHeight(display, screenNr :INTEGER) :INTEGER;
PROCEDURE [extern, "XDefaultVisual"] XDefaultVisual(display, screenNr :INTEGER) :INTEGER;  (* visual *)
PROCEDURE [extern, "XDefaultRootWindow"] XDefaultRootWindow(display :INTEGER) :INTEGER;  (* Window *)
PROCEDURE [extern, "XDefaultDepth"] XDefaultDepth(display, screenNr :INTEGER) :INTEGER;
PROCEDURE [extern, "XSelectInput"] XSelectInput(display, window, event_mask :INTEGER);
PROCEDURE [extern, "XMapWindow"] XMapWindow(display, window :INTEGER);
PROCEDURE [extern, "XNextEvent"] XNextEvent(display, XEvent_p :INTEGER);
PROCEDURE [extern, "XPending"] XPending(display :INTEGER) :INTEGER;
PROCEDURE [extern, "XLookupString"] XLookupString(key_event, buffer_return, buflen, keysym_return, status_in_out :INTEGER) :INTEGER;
PROCEDURE [extern, "XCreateImage"] XCreateImage(display, visual, depth, format, offset, data,
	width, height, bitmap_pad, bytes_per_line :INTEGER) :INTEGER; (* ptr to XImage *)
PROCEDURE [extern, "XPutImage"] XPutImage(display, window, gc, image, sx, sy, dx, dy, w, h :INTEGER);
PROCEDURE [extern, "XSetCommand"] XSetCommand*(display: Display; window: Window; argc: INTEGER; argv: INTEGER);
PROCEDURE [extern, "XCopyArea"] XCopyArea*(display: Display; source, dest: Pixmap; gc: GC; sx, sy, w, h, dx, dy: INTEGER);
	

PROCEDURE init;
BEGIN
	display := XOpenDisplay (0);
	IF display = 0 THEN Out.String("error: can not open X11 display."); Out.Ln; ASSERT(FALSE) END;
	(* ri := XSynchronize (display, 1); *)
	connectionNr := XConnectionNumber (display);
	//ASSERT (connectionNr < unix.FD_SETSIZE);
	//NEW (readX11); unix.FD_ZERO(readX11); unix.FD_SET (connectionNr, readX11);
	screen := XDefaultScreen (display); gc := XDefaultGC (display, screen);
	ScreenWidth := XDisplayWidth (display, screen); ScreenHeight := XDisplayHeight (display, screen);
	base := unix.malloc (ScreenWidth * ScreenHeight * 4);
	IF base = 0 THEN
		Out.String("error: can not allocate screen buffer "); Out.Int(ScreenWidth, 0); 
		Out.String(" x "); Out.Int(ScreenHeight, 0); Out.Ln;
		ASSERT(FALSE);
	END;
	stride := ScreenWidth * 4;
	img := XCreateImage (display, XDefaultVisual (display, screen), XDefaultDepth (display, screen),
		ZPixmap, 0, base, ScreenWidth, ScreenHeight, 32, 0);
END init;


PROCEDURE finish*;
BEGIN
	IF display # 0 THEN XCloseDisplay(display); display := 0 END;
END finish;


PROCEDURE createWindow* (w, h :INTEGER);
VAR 
	eventMask :INTEGER;
BEGIN
	IF (w > ScreenWidth) OR (h > ScreenHeight) THEN
		Out.String("error: X11.createWindow: window too large"); ASSERT(FALSE);
	END;
	ASSERT ((w >= 0) & (h >= 0));
	window := XCreateWindow (display, XDefaultRootWindow (display), 0, 0, w, h, 0,
		XDefaultDepth (display, screen), InputOutput, XDefaultVisual (display, screen), 0, 0);
	winWidth := w; winHeight := h;
	eventMask := StructureNotifyMask + ExposureMask + KeyPressMask + ButtonPressMask;
	XSelectInput (display, window, eventMask);
	XMapWindow (display, window);
END createWindow;


PROCEDURE screenBegin*;
(* intended to enable future cooperation with iOS / MacOS *)
BEGIN
	ASSERT (~painting); painting := TRUE
END screenBegin;


PROCEDURE screenEnd*;
BEGIN
	ASSERT (painting);
	XPutImage (display, window, gc, img, 0, 0, 0, 0, winWidth, winHeight);
	painting := FALSE;
END screenEnd;


PROCEDURE readInt (e :XEvent; i :INTEGER) :INTEGER;
        (* treat XEvent byte array as int array *)
VAR n :INTEGER;
BEGIN
        ASSERT (i >= 0);
        ASSERT (i < 48);
        i := i * 4;
        n := e.val[i+3]*1000000H + e.val[i+2]*10000H + e.val[i+1]*100H + e.val[i];
RETURN n
END readInt;


PROCEDURE nextEvent* (msTimeOut :INTEGER; VAR ev :EventPars);
VAR 
	_type, n, ri :INTEGER;
	event :XEvent;
	x, y, w, h :INTEGER;
	timeout :unix.timespec;
BEGIN

(* struct XEvent (32-bit):
any:   4 type   4 serial   4 send_event   4 display   4 window
expose:   20 any   4 x, y, w, h, count
xconfigure:   24 any   4 x, y, w, h
xkey / xbutton / xmotion:   24 any   4 sub_window   4 time_ms   4 x, y, x_root, y_root   4 state   4 keycode/button
*)
	_type := 0;
	WHILE _type = 0 DO
		IF (msTimeOut > 0) & (XPending(display) = 0) THEN
			timeout.tv_sec := msTimeOut DIV 1000; timeout.tv_usec := (msTimeOut MOD 1000) * 1000;
			ri := unix.select (connectionNr + 1, NIL, NIL, NIL, timeout); ASSERT (ri # -1);
			IF ri = 0 THEN _type := EventTimeOut; ev[1] := 0; ev[2] := 0; ev[3] := 0; ev[4] := 0 END;
		END;
		IF _type = 0 THEN
			XNextEvent (display, SYSTEM.ADR(event));
			CASE readInt (event, 0) OF
			| Expose :
				x := readInt (event, 5 + 5 * bit64); y := readInt (event, 6 + 5 * bit64);
				w := readInt (event, 7 + 5 * bit64); h := readInt (event, 8 + 5 * bit64);
				XPutImage (display, window, gc, img, x, y, x, y, w, h);
			| ConfigureNotify :
				w := readInt (event, 8 + 6 * bit64); h := readInt (event, 9 + 6 * bit64);
				IF (w # winWidth) & (h # winHeight) THEN
						ASSERT ((w >= 0) & (h >= 0));
						IF w > ScreenWidth THEN w := ScreenWidth END;
						IF h > ScreenHeight THEN h := ScreenHeight END;
						winWidth := w; winHeight := h;
						ev[0] := EventResize; ev[1] := 0; ev[2] := w; ev[3] := h; ev[4] := 0;
				END;
			| KeyPress :
				_type := EventKeyPressed;
				x := XLookupString (SYSTEM.ADR(event), 0, 0, SYSTEM.ADR(n), 0);  (* KeySym *)
				IF (n = 8) OR (n = 10) OR (n >= 32) & (n <= 126) THEN ev[1] := 1 ELSE ev[1] := 0; n := 0 END;  (* isprint *)
				ev[2] := readInt (event, 13 + 8 * bit64); (* keycode *)
				ev[3] := readInt (event, 12 + 8 * bit64); (* state *)
				ev[4] := n;  (* KeySym *)
			| ButtonPress :
				_type := EventButtonPressed;
				ev[1] := readInt (event, 13 + 8 * bit64); (* button *)
				ev[2] := readInt (event, 8 + 8 * bit64);  (* x *)
				ev[3] := readInt (event, 9 + 8 * bit64);  (* y *)
				ev[4] := readInt (event, 12 + 8 * bit64); (* state *)
			ELSE
			END
		END
	END;
	ev[0] := _type
END nextEvent;


PROCEDURE clear* (color :INTEGER);   (* fill window area with color *)
VAR p, i, j :INTEGER;
BEGIN
	FOR j := 0 TO winHeight-1 DO
		p := base + j*stride;
		FOR i := 0 TO winWidth-1 DO SYSTEM.PUT32 (p, color); INC (p, 4) END
	END
END clear;


BEGIN
	//init;
END X11.

