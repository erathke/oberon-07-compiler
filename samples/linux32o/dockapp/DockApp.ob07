MODULE DockApp;
IMPORT SYSTEM, Out := Out_sys,
	File IN "./File.ob07",
	X11 IN "./X11.ob07";

CONST
	NULL = 0;

	DONone* = 0;    // simple on/off flag
	DOInteger* = 1; // an integer number
	DOString* = 2;  // a string
	DONatural* = 3; // positive integer number

TYPE
	ADDRESS = INTEGER;
	DAShapedPixmap* = ADDRESS;
	DACallbacks* = PROCEDURE;
	cstr = INTEGER;
	
	Callbacks* = RECORD
		// the dockapp window was destroyed
		destroy*: PROCEDURE [ccall];
		// button pressed
		buttonPressed*: PROCEDURE [ccall] (button, state, x, y: INTEGER);
		// button released
		buttonReleased*: PROCEDURE [ccall] (button, state, x, y: INTEGER);
		// pointer motion
		motion*: PROCEDURE [ccall] (x, y: INTEGER);
		// pointer entered dockapp window
		enter*: PROCEDURE [ccall];
		// pointer left dockapp window
		leave*: PROCEDURE [ccall];
		// timer expired
		timeout*: PROCEDURE [ccall]
	END;

	ProgramOption* = POINTER TO RECORD
		shortForm: ARRAY 3 OF CHAR;
		longForm: ARRAY 32 OF CHAR;
		description: ARRAY 128 OF CHAR;
		_type: BYTE;
		used: BOOLEAN;
		value*: RECORD 
			ptr: INTEGER;
			integer*: INTEGER;
			string*: ARRAY 32 OF CHAR
		END
	END;
	
	DAProgramOption = RECORD
		shortForm: INTEGER;
		longForm: INTEGER;
		description: INTEGER;
		_type: ARRAY 2 OF BYTE; // short
		used: INTEGER;
		value: INTEGER // a ptr for the value that was passed
	END;

VAR
	Window*: X11.Window;
	Display*: X11.Display;
	GC*: X11.GC;
	
// libdockapp
PROCEDURE [extern, "DAParseArguments"] DAParseArguments(argc: INTEGER; argv: cstr; options: INTEGER; 
	count: INTEGER; programDesc, versionDesc: cstr);
PROCEDURE [extern, "DASetExpectedVersion"] SetExpectedVersion*(version: INTEGER);
PROCEDURE [extern, "DAOpenDisplay"] DAOpenDisplay(display: cstr; argc: INTEGER; argv: cstr);
PROCEDURE [extern, "DAInitialize"] DAInitialize(display, name: cstr; width, height: INTEGER; argc: INTEGER; argv: cstr);
PROCEDURE [extern, "DAMakePixmap"] DMakePixmap(): X11.Pixmap;
PROCEDURE [extern, "DASetPixmap"] SetPixmap*(pixmap: X11.Pixmap);
PROCEDURE [extern, "DASetShapeWithOffset"] SetShapeWithOffset*(pixmap: X11.Pixmap; offsx, offsy: INTEGER);
PROCEDURE [extern, "DAMakePixmapFromFile"] DAMakePixmapFromFile(filename: cstr; pixmap: X11.Pixmap; mask: ADDRESS; w, h: INTEGER): INTEGER;
PROCEDURE [extern, "DASetCallbacks"] DASetCallbacks(callbacks: INTEGER);
PROCEDURE [extern, "DASetTimeout"] SetTimeout*(milis: INTEGER);
PROCEDURE [extern, "DAShow"] Show*();
PROCEDURE [extern, "DAEventLoop"] EventLoop*();
// glue
PROCEDURE [extern, "setWindowAndDisplay"] SetWindowAndDisplay(window, display: INTEGER);
PROCEDURE [extern, "setGC"] SetGC(gc: INTEGER);


PROCEDURE NewOption*(shortForm: ARRAY OF CHAR; longForm: ARRAY OF CHAR; 
	description: ARRAY OF CHAR; _type: BYTE): ProgramOption;
VAR
	option: ProgramOption;
BEGIN
	NEW(option);
	option.shortForm := shortForm;
	option.longForm := longForm;
	option.description := description;
	option._type := _type;
	RETURN option
END NewOption;


PROCEDURE MakePixmap*(VAR pixmap: X11.Pixmap);
BEGIN
	pixmap := DMakePixmap();
END MakePixmap;


PROCEDURE MakePixmapFromFile*(filename: ARRAY OF CHAR; VAR pixmap, mask: X11.Pixmap; VAR w, h: INTEGER): BOOLEAN;
BEGIN 
	RETURN DAMakePixmapFromFile(SYSTEM.ADR(filename[0]), SYSTEM.ADR(pixmap), SYSTEM.ADR(mask), SYSTEM.ADR(w), SYSTEM.ADR(h)) > 0
END MakePixmapFromFile;


PROCEDURE ParseArguments*(argc: INTEGER; argv: ARRAY OF ARRAY OF CHAR; VAR opt: ProgramOption; 
	count: INTEGER; programDesc, versionDesc: ARRAY OF CHAR);
CONST
	MAX_PARAMS = 6;
VAR
	i: INTEGER;
	params: ARRAY MAX_PARAMS OF INTEGER;
	dopt: DAProgramOption;
	ch: CHAR;
BEGIN
	FOR i := 0 TO argc - 1 DO
		params[i] := SYSTEM.ADR(argv[i]);
	END;
	IF count > 0 THEN
		dopt.shortForm := SYSTEM.ADR(opt.shortForm);
		dopt.longForm := SYSTEM.ADR(opt.longForm);
		dopt.description := SYSTEM.ADR(opt.description);
		
		CASE opt._type OF
		| DOInteger, DONatural:
			dopt._type[0] := opt._type;
			dopt.value := SYSTEM.ADR(opt.value.integer);
		| DOString:
			dopt._type[0] := DOString;
			dopt.value := SYSTEM.ADR(opt.value.ptr);
		ELSE
			dopt._type[0] := DONone;
		END;
		
		DAParseArguments(argc, SYSTEM.ADR(params), SYSTEM.ADR(dopt), count, SYSTEM.ADR(programDesc[0]), SYSTEM.ADR(versionDesc[0]));
		
		CASE opt._type OF
		| DOString:
			i := 0;
			REPEAT
				SYSTEM.GET(opt.value.ptr, ch);
				opt.value.string[i] := ch;
				INC(opt.value.ptr); INC(i);
			UNTIL ch = 0X;
		ELSE
		END;
		
	ELSE
		DAParseArguments(argc, SYSTEM.ADR(params), NULL, count, SYSTEM.ADR(programDesc[0]), SYSTEM.ADR(versionDesc[0]));
	END;
END ParseArguments;


PROCEDURE OpenDisplay*(display: INTEGER; argc: INTEGER; argv: ARRAY OF ARRAY OF CHAR);
BEGIN
	DAOpenDisplay(display, argc, SYSTEM.ADR(argv));
END OpenDisplay;


PROCEDURE Initialize*(display, name: ARRAY OF CHAR; width, height: INTEGER; argc: INTEGER; argv: ARRAY OF ARRAY OF CHAR);
BEGIN
	DAInitialize(SYSTEM.ADR(display[0]), SYSTEM.ADR(name[0]), width, height, 0, NULL);
	SetWindowAndDisplay(SYSTEM.ADR(Window), SYSTEM.ADR(Display));
	SetGC(SYSTEM.ADR(GC));
END Initialize;


PROCEDURE SetCallbacks*(callbacks: Callbacks);
BEGIN
	DASetCallbacks(SYSTEM.ADR(callbacks));
END;


END DockApp.
