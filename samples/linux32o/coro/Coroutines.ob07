MODULE Coroutines;
IMPORT SYSTEM, Out := Out_sys;

CONST 
	IDLE* = 0;
	RUNNING* = 1;
	SUSPENDED* = 2;
	DEAD* = 4;
	
	STACK_SIZE = 4096;
	
TYPE
	UINT32 = INTEGER;
	PID* = INTEGER;
	
	Userdata* = POINTER TO RECORD
	END;
	
	Context* = POINTER TO ContextDesc;
	
	Handler* = PROCEDURE (ctx: Context; r: INTEGER): INTEGER;
	
	Stack = POINTER TO RECORD
		data: ARRAY STACK_SIZE OF BYTE;
		size: INTEGER
	END;
	
	ContextDesc = RECORD
		csp: UINT32;
		stack: Stack;
		handler: Handler;
		user*: Userdata;
		status: INTEGER
	END;


PROCEDURE [extern, "coroutine_init32"] coro_init(ctx: UINT32; handlerAddr: UINT32; stackAddr: UINT32);
PROCEDURE [extern, "coroutine_yield32"] coro_yield(ctx: UINT32; data: UINT32): INTEGER;
PROCEDURE [extern, "coroutine_yield32"] coro_resume(ctx: UINT32; data: UINT32): INTEGER;


PROCEDURE [ccall] EntryPoint(ctxAddr: UINT32; r: INTEGER): INTEGER;
VAR
	ctx: Context;
	value: INTEGER;
BEGIN
	ctx := SYSTEM.VAL(ctxAddr, Context);
	value := ctx.handler(ctx, r);
	ctx.status := DEAD;
	RETURN value
END;


PROCEDURE Create*(handler: Handler; data: Userdata): Context;
VAR
	ctx: Context;
	stack: Stack; 
	baseAddr, spAddr, spIdx : UINT32;
	handlerAddr: UINT32;
BEGIN
	NEW(stack);
	stack.size := STACK_SIZE;
	baseAddr := SYSTEM.ADR(stack.data[0]);
	spIdx := stack.size - SYSTEM.SIZE(ContextDesc);
	spAddr := SYSTEM.ADR(stack.data[spIdx]);
	handlerAddr := SYSTEM.ADR(EntryPoint);
	
	ctx := SYSTEM.VAL(spAddr, Context);
	ctx.csp := spAddr;
	ctx.stack := stack;
	ctx.handler := handler;
	ctx.user := data;
	
	coro_init(spAddr, handlerAddr, spAddr);
	
	RETURN ctx
END Create;


PROCEDURE Yield*(ctx: Context; r: INTEGER): INTEGER;
VAR
	value: INTEGER;
	addr: UINT32;
BEGIN
	
	IF ctx.status = RUNNING THEN
		addr := SYSTEM.VAL(ctx, UINT32);
		ctx.status := SUSPENDED;
		value := coro_yield(addr, r);
	ELSE
		CASE ctx.status OF
		| DEAD: Out.String("cannot yield dead coroutine"); Out.Ln;
		| IDLE: Out.String("coroutine not running"); Out.Ln;
		END;
	END;
	
	RETURN value
END Yield;


PROCEDURE Resume*(ctx: Context; r: INTEGER): INTEGER;
VAR
	value: INTEGER;
	addr: UINT32;
BEGIN
	
	IF (ctx.status = IDLE) OR (ctx.status = SUSPENDED) THEN
		ctx.status := RUNNING;
		addr := SYSTEM.VAL(ctx, UINT32);
		value := coro_resume(addr, r);
	ELSE
		CASE ctx.status OF
		| DEAD: Out.String("cannot resume dead coroutine"); Out.Ln;
		END;
	END;
	
	RETURN value
END Resume;
	
END Coroutines.
