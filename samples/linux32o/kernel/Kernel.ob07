MODULE Kernel;
IMPORT SYSTEM, Devices;

CONST 
	VideoMemoryAddr = 0b8000H;
	ScreenWidth = 80;
	ScreenHeight = 25;
	EOL = 0AX;
	
	// Colors
	BLACK    = 00H;
	BLUE     = 01H;
	GREEN    = 02H;
	CYAN     = 03H;
	RED      = 04H;
	MAGENTA  = 05H;
	BROWN    = 06H;
	WHITE    = 07H;
	GRAY     = 08H;
	LBLUE    = 09H;
	LGREEN   = 0AH;
	LCYAN    = 0BH;
	LRED     = 0CH;
	LMAGENTA = 0DH;
	YELLOW   = 0EH;
	BWHITE   = 0FH;
	
	// Characters
	SPACE = 20H;
	
	// GDT
	GDT_NULL = 0;
	GDT_CODE = 1;
	GDT_DATA = 2;
	
	GDT_SIZE = 3;
	
	// IDT
	IDT_SIZE = 256;
	
	// SYSCALL
	SYS_exit = 1;
	SYS_write = 4;
	
	// In/Out
	STDIN = 0;
	STDOUT = 1;
	
TYPE
	Message = POINTER TO RECORD
		i: INTEGER;
		s: ARRAY 32 OF CHAR
	END;
	
	UINT32 = INTEGER;
	UINT16 = WCHAR;
	UINT8 = BYTE;
	
	SegmentDescriptor = RECORD [noalign]
		limit_low: UINT16;
		base_low: UINT16;
		base_middle, access_byte, limit_and_flags, base_high: UINT8
	END;
	
	GDT = ARRAY GDT_SIZE OF SegmentDescriptor;
	
	GateDescriptor = RECORD [noalign]
		handlerAddrLow, codeSeg: UINT16;
		reserved, access: UINT8;
		handlerAddrHi: UINT16
	END;

	IDT = ARRAY IDT_SIZE OF GateDescriptor;
	
	TableDesc = RECORD [noalign]
		size: UINT16;
		addr: UINT32
	END;
	
	CPU = RECORD [noalign]
		eax, ebx, ecx, edx: UINT32;
        esi, edi, ebp: UINT32;
        error, eip, cs, eflags, esp, ss: UINT32
	END;
	
VAR
	cursor: RECORD
		line, column: INTEGER
	END;
	masterCmd, masterData: Devices.Port;
	slaveCmd, slaveData: Devices.Port;
	keyboard: Devices.Keyboard;

// ----------------------------SCREEN-------------------------------------------

PROCEDURE ClearScreen(bgColor: BYTE);
VAR
	x, y: INTEGER;
	offset: INTEGER;
BEGIN
	// clear screen
	offset := VideoMemoryAddr;
	FOR y:= 0 TO ScreenHeight - 1 DO
		FOR x:= 0 TO ScreenWidth - 1 DO
			SYSTEM.PUT16(offset, LSL(bgColor, 12) + SPACE);
			INC(offset, 2);
		END;
	END;
	
	cursor.line := 0;
	cursor.column := 0;

END ClearScreen;


PROCEDURE PrintLn();
BEGIN
	INC(cursor.line);
	cursor.column := 0;
	IF cursor.line = ScreenHeight THEN
		ClearScreen(BLACK);
		cursor.line := 0;
	END;
END PrintLn;


PROCEDURE Print(msg: ARRAY OF CHAR; fgColor, bgColor: BYTE);
VAR
	i: INTEGER;
	offset: INTEGER;
	ch: INTEGER;
	msgLen: INTEGER;
	c: CHAR;
BEGIN
	i := 0;
	msgLen := LENGTH(msg);
	offset := VideoMemoryAddr + (cursor.line * ScreenWidth * 2) + (cursor.column * 2);
	WHILE i < msgLen DO
		c := msg[i];
		CASE c OF
		|EOL:
			PrintLn();
			offset := VideoMemoryAddr + (cursor.line * ScreenWidth * 2) + (cursor.column * 2);
		ELSE
			ch :=  LSL(bgColor, 12) + LSL(fgColor, 8) + ORD(c);
			SYSTEM.PUT16(offset, ch);
			INC(offset, 2);
			INC(cursor.column);
		END;
		INC(i);
		
		IF cursor.column >= ScreenWidth THEN
			PrintLn();
		END;
	END;
END;


PROCEDURE PrintChar(ch: CHAR; fgColor, bgColor: BYTE);
VAR
	s: ARRAY 2 OF CHAR;
BEGIN
	s[0] := ch;
	Print(s, fgColor, bgColor);
END PrintChar;


PROCEDURE PrintHex8(value: BYTE; fgColor, bgColor: BYTE);
VAR
	str: ARRAY 3 OF CHAR;
	hex: ARRAY 17 OF CHAR;
	s, mask: SET;
	i: INTEGER;
BEGIN
    str := "00";
    hex := "0123456789ABCDEF";
    mask := BITS(0FH);
    
    s := BITS(LSR(value, 4)) * mask;
    i := ORD(s);
    str[0] := hex[i];
    
    s := BITS(value) * mask;
    i := ORD(s);
    str[1] := hex[i];
    
    Print(str, fgColor, bgColor);
END PrintHex8;


PROCEDURE PrintHex32(value: INTEGER; fgColor, bgColor: BYTE);
VAR
	value8: BYTE;
	i: INTEGER;
	addr: INTEGER;
BEGIN
	addr := SYSTEM.ADR(value);
	FOR i := 3 to 0 BY -1 DO
		SYSTEM.MOVE(addr + i, SYSTEM.ADR(value8), 1);
		PrintHex8(value8, fgColor, bgColor);
	END;
END PrintHex32;


PROCEDURE IntToStr(x: INTEGER; VAR str: ARRAY OF CHAR);
VAR
    i, a: INTEGER;
	zero: INTEGER;
BEGIN
	i := 0;
	a := x;
	zero := ORD('0');

	IF x < 0 THEN
		str[i] := "-";
		a := -a;
		x := -x;
		INC(i);
	END;

	REPEAT
		INC(i); a := a DIV 10
	UNTIL a = 0;

	str[i] := 0X;

	REPEAT
		DEC(i);
		str[i] := CHR(x MOD 10 + zero);
		x := x DIV 10
	UNTIL x = 0
END IntToStr;


PROCEDURE PrintInt(i: INTEGER; fgColor, bgColor: BYTE);
VAR
	str: ARRAY 32 OF CHAR;
BEGIN
	IntToStr(i, str);
	Print(str, fgColor, bgColor);
END PrintInt;


// ----------------------------KERNEL-------------------------------------------


PROCEDURE [oberon-] syscall(eax, ebx, ecx, edx: INTEGER): INTEGER;
BEGIN
    SYSTEM.CODE(
    053H,               (*  push    ebx                    *)
    08BH, 045H, 008H,   (*  mov     eax, dword [ebp +  8]  *)
    08BH, 05DH, 00CH,   (*  mov     ebx, dword [ebp + 12]  *)
    08BH, 04DH, 010H,   (*  mov     ecx, dword [ebp + 16]  *)
    08BH, 055H, 014H,   (*  mov     edx, dword [ebp + 20]  *)
    0CDH, 080H,         (*  int     128                    *)
    05BH,               (*  pop     ebx                    *)
    05DH,               (*  pop     ebp                    *)
    0C2H, 010H, 000H    (*  ret     16                     *)
    );
    RETURN 0
END syscall;


// ------------------------KERNEL: BOOT-----------------------------------------
PROCEDURE Process(steps: INTEGER);
VAR
	i, j: INTEGER;
	msg: Message;
BEGIN
	FOR i := 0 to steps DO
		NEW(msg);
		msg.s := ".";
		Print(msg.s, LGREEN, BLACK);
		FOR j := 0 TO 999999 DO END;
		DISPOSE(msg);
		ASSERT(i # 84);
	END;
END Process;


PROCEDURE ShowMultibootInfo*(multiboot_structure: INTEGER; multiboot_magic: INTEGER);
VAR
	magic, mem_up, mem_low, boot_dev: INTEGER;
	
	PROCEDURE ShowMemInfo(mem: INTEGER);
	CONST
		KB = 1024;
	VAR
		mem_mkb: INTEGER;
	BEGIN
		PrintHex32(mem, CYAN, BLACK);
		Print(" => [", CYAN, BLACK);
		IF mem < KB THEN
			PrintInt(mem, CYAN, BLACK);
			Print(" Kbytes]", CYAN, BLACK);
		ELSE
			mem_mkb := mem DIV KB;
			PrintInt(mem_mkb, CYAN, BLACK);
			Print(" Mbytes]", CYAN, BLACK);
		END;
	END ShowMemInfo;

BEGIN
// https://www.gnu.org/software/grub/manual/multiboot/multiboot.html#Boot-information-format
	SYSTEM.GET32(multiboot_structure, magic);
	SYSTEM.GET32(multiboot_structure + 4, mem_low);
	SYSTEM.GET32(multiboot_structure + 8, mem_up);
	SYSTEM.GET32(multiboot_structure + 12, boot_dev);
	
	Print("--------------------------------------------------------------------------------", WHITE, BLACK);
	Print("multiboot_magic: ", BLUE, BLACK); PrintHex32(multiboot_magic, CYAN, BLACK); PrintLn();
	Print("multiboot_structure: ", BLUE, BLACK); PrintHex32(multiboot_structure, CYAN, BLACK); PrintLn();
	Print("multiboot_structure/magic: ", BLUE, BLACK); PrintHex32(magic, CYAN, BLACK); PrintLn();
	Print("multiboot_structure/mem_lower: ", BLUE, BLACK); ShowMemInfo(mem_low); PrintLn();
	Print("multiboot_structure/mem_upper: ", BLUE, BLACK); ShowMemInfo(mem_up); PrintLn();
	Print("multiboot_structure/boot_device: ", BLUE, BLACK); PrintHex32(boot_dev, CYAN, BLACK); PrintLn();
	Print("--------------------------------------------------------------------------------", WHITE, BLACK); 
	PrintLn();

END ShowMultibootInfo;


PROCEDURE [oberon] LoadGDT(addr: UINT32);
BEGIN
	SYSTEM.CODE(
		8bH, 45H, 08H,	(* mov    0x8(%ebp), %eax *)
		0FH, 01H, 10H	(* lgdtl  (%eax) *)
	);
END LoadGDT;


PROCEDURE [extern, "reload_segs"] ReloadSegments();


PROCEDURE InstallGDT(VAR gdt: GDT);
CONST
	SEGMENT_CODE_TYPE  = 09AH;
	SEGMENT_DATA_TYPE  = 092H;
	SEGMENT_FLAGS_PART = 00CH;

VAR
	gdtAddr: TableDesc;

	PROCEDURE NewSegmentDescriptor(VAR segment: SegmentDescriptor; base_address, limit: UINT32; access_byte, flags: UINT8);
	VAR
		s1, s2: SET;
	BEGIN
		s1 := BITS(base_address) * BITS(0FFFFH);
		SYSTEM.PUT16(SYSTEM.ADR(segment.base_low), ORD(s1));
		s1 := BITS(LSR(base_address, 16)) * BITS(0FFH);
		SYSTEM.PUT8(SYSTEM.ADR(segment.base_middle), ORD(s1));
		s1 := BITS(LSR(base_address, 24)) * BITS(0FFH);
		SYSTEM.PUT8(SYSTEM.ADR(segment.base_high), ORD(s1));
		
		s1 := BITS(limit) * BITS(0FFFFH);
		SYSTEM.PUT16(SYSTEM.ADR(segment.limit_low), ORD(s1));
		
		s1 := BITS(LSR(limit, 16)) * BITS(0FH);
		SYSTEM.PUT8(SYSTEM.ADR(segment.limit_and_flags), ORD(s1));
		
		s1 := BITS(segment.limit_and_flags);
		s2 := BITS(LSL(flags, 4)) * BITS(0F0H);
		s1 := s1 + s2;
		SYSTEM.PUT8(SYSTEM.ADR(segment.limit_and_flags), ORD(s1));
		
		segment.access_byte := access_byte;
	END;

BEGIN
	// segments
	NewSegmentDescriptor(gdt[GDT_NULL], 0, 0, 0, 0); // null
	NewSegmentDescriptor(gdt[GDT_CODE], 0, 0FFFFFH, SEGMENT_CODE_TYPE, SEGMENT_FLAGS_PART); // code
	NewSegmentDescriptor(gdt[GDT_DATA], 0, 0FFFFFH, SEGMENT_DATA_TYPE, SEGMENT_FLAGS_PART); // data
	
	// Load GDT
	SYSTEM.PUT32(SYSTEM.ADR(gdtAddr.addr), SYSTEM.ADR(gdt));
	SYSTEM.PUT16(SYSTEM.ADR(gdtAddr.size), SYSTEM.SIZE(GDT) - 1);
	
	LoadGDT(SYSTEM.ADR(gdtAddr));
	ReloadSegments();

END InstallGDT;


// ----------------------KERNEL: INTERRUPTS-------------------------------------
PROCEDURE NewGateDescriptor(VAR gd: GateDescriptor; codeSeg: UINT16; handler: UINT32; privLvl, _type: UINT8);
CONST 
	IDT_DESC_PRESENT = 080H;
VAR
	accessMask, presentMask, privMask, _typeMask: SET;
	s1: SET;
BEGIN
	s1 := BITS(handler) * BITS(0FFFFH);
	SYSTEM.PUT16(SYSTEM.ADR(gd.handlerAddrLow), ORD(s1));
	s1 := BITS(LSR(handler, 16)) * BITS(0FFFFH);
	SYSTEM.PUT16(SYSTEM.ADR(gd.handlerAddrHi), ORD(s1));
	gd.codeSeg := codeSeg;
	
	presentMask := BITS(IDT_DESC_PRESENT);
	privMask := BITS(LSL(ORD(BITS(privLvl) * {03H}), 5));
	_typeMask := BITS(_type);
	accessMask := presentMask + privMask + _typeMask;
	
	gd.access := ORD(accessMask);
	gd.reserved := 0;

END NewGateDescriptor;


PROCEDURE LoadIDT(addr: UINT32);
BEGIN
	SYSTEM.CODE(
		8bH, 45H, 08H,	(* mov    0x8(%ebp), %eax *)
		0FH, 01H, 18H	(* lidt  (%eax) *)
	);
END;


PROCEDURE [extern, "set_handlers"] SetHandlers(addr: UINT32);


PROCEDURE InstallIDT(VAR idt: IDT; VAR gdt: GDT);
CONST
	IDT_INTERRUPT_GATE = 0EH;
	HW_INTERRUPT_OFFSET = 20H;
	SYS_INTERRUPT_OFFSET = 080H;

VAR
	gdtCodeSeg: UINT16;
	gdtCodeSegOffs: INTEGER;
	i: INTEGER;
	idtp: TableDesc;
	handlers: ARRAY 256 OF UINT32;

BEGIN
	
	SetHandlers(SYSTEM.ADR(handlers));
	
	gdtCodeSegOffs := SYSTEM.ADR(gdt[GDT_CODE]) - SYSTEM.ADR(gdt[GDT_NULL]);
	SYSTEM.PUT16(SYSTEM.ADR(gdtCodeSeg), gdtCodeSegOffs);
	
	// Exceptions
	FOR i := 00H TO 13H DO
		NewGateDescriptor(idt[i], gdtCodeSeg, handlers[i], 0, IDT_INTERRUPT_GATE);
	END;
	
	// Hardware interrupts
	FOR i := HW_INTERRUPT_OFFSET TO HW_INTERRUPT_OFFSET + 0FH DO
		NewGateDescriptor(idt[i], gdtCodeSeg, handlers[i], 0, IDT_INTERRUPT_GATE);
	END;
	
	// Syscalls
	FOR i := SYS_INTERRUPT_OFFSET TO SYS_INTERRUPT_OFFSET DO
		NewGateDescriptor(idt[i], gdtCodeSeg, handlers[i], 0, IDT_INTERRUPT_GATE);
	END;
	
	// Initialize PICs
	Devices.Write8(masterCmd, 011H);
	Devices.Write8(slaveCmd, 011H);
	
	Devices.Write8(masterData, HW_INTERRUPT_OFFSET);
	Devices.Write8(slaveData, HW_INTERRUPT_OFFSET + 8);
	
	Devices.Write8(masterData, 04H);
	Devices.Write8(slaveData, 02H);
	
	Devices.Write8(masterData, 01H);
	Devices.Write8(slaveData, 01H);
	
	Devices.Write8(masterData, 00H);
	Devices.Write8(slaveData, 00H);
	
	// Initialize keyboard
	Devices.InitKeyboard(keyboard);
	
	// Load IDT
	SYSTEM.PUT32(SYSTEM.ADR(idtp.addr), SYSTEM.ADR(idt));
	SYSTEM.PUT16(SYSTEM.ADR(idtp.size), SYSTEM.SIZE(IDT) - 1);
	LoadIDT(SYSTEM.ADR(idtp));
	
END;


PROCEDURE CreateDevices();
BEGIN
	Devices.NewPort(masterCmd, 020H);
	Devices.NewPort(masterData, 021H);
	Devices.NewPort(slaveCmd, 0A0H);
	Devices.NewPort(slaveData, 0A1H);
	Devices.NewKeyboard(keyboard);
END CreateDevices;


PROCEDURE DisableInterrupts();
BEGIN
	SYSTEM.CODE(0FAH); (* cli *)
END DisableInterrupts;


PROCEDURE EnableInterrupts();
BEGIN
	SYSTEM.CODE(0FBH); (* sti *)
END EnableInterrupts;


PROCEDURE kernelMain*(multiboot_structure: INTEGER; multiboot_magic: INTEGER);
VAR
	gdt: GDT;
	idt: IDT;
BEGIN
	ClearScreen(BLACK);
	ShowMultibootInfo(multiboot_structure, multiboot_magic);

	CreateDevices();
	
	DisableInterrupts();
	
	InstallGDT(gdt);
	InstallIDT(idt, gdt);
	
	EnableInterrupts();
	
	Print("Booting OS...", BLUE, BLACK);
	Process(100); PrintHex8(22, YELLOW, BROWN); PrintLn();
	WHILE TRUE DO END;
END;


PROCEDURE kernelPrint*(addr, size: INTEGER);
VAR
	msg: ARRAY 32 OF CHAR;
BEGIN
	SYSTEM.MOVE(addr, SYSTEM.ADR(msg), MIN(size, 32));
	Print(msg, WHITE, BLACK);
END kernelPrint;


PROCEDURE kernelPrintInt*(value: INTEGER);
BEGIN
	PrintHex32(value, WHITE, BLACK);
	PrintLn();
END kernelPrintInt;



PROCEDURE [extern, "_stop"] Halt();


PROCEDURE GetSyscall(esp: UINT32; VAR cpu: CPU);
BEGIN
	SYSTEM.GET(esp, cpu.eax);
	SYSTEM.GET(esp + 4, cpu.ebx);
	SYSTEM.GET(esp + 8, cpu.ecx);
	SYSTEM.GET(esp + 12, cpu.edx);
END GetSyscall; 


PROCEDURE [oberon] kernelInterruptHandler*(interrupt: UINT8; esp: UINT32): UINT32;
CONST
	TIMER = 020H;
	KEYBOARD = 021H;
	SYSCALL = 0A0H;
VAR
	key: CHAR;
	cpu: CPU;
BEGIN

	CASE interrupt OF
	| TIMER: // does nothing for now
	| KEYBOARD:
		IF Devices.ReadKey(keyboard, key) THEN
			PrintChar(key, BLACK, MAGENTA);
		END;
	| SYSCALL:
		GetSyscall(esp, cpu);
		CASE cpu.eax OF
		| SYS_exit: Halt();
		| SYS_write:
			kernelPrint(cpu.ecx, cpu.edx);
		ELSE
			PrintLn(); Print("Unknown syscall:", BROWN, YELLOW); 
		END;
	ELSE
		PrintLn();
		Print("UNHANDLED INTERRUPT: ", BLACK, MAGENTA); PrintHex8(interrupt, BLACK, MAGENTA);
		PrintLn();
	END;

	// Acknowledge the PICs for message received
	Devices.Write8(masterCmd, 020H);
	IF interrupt >= 28H THEN
		Devices.Write8(slaveCmd, 020H);
	END;
	
	RETURN esp
	
END kernelInterruptHandler;


END Kernel.
