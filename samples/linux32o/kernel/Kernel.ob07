MODULE Kernel;
IMPORT SYSTEM, Devices;

CONST 
	VideoMemoryAddr = 0b8000H;
	ScreenWidth = 80;
	ScreenHeight = 25;
	EOL = 0AX;
	
	// Colors
	BLACK    = 00H;
	BLUE     = 01H;
	GREEN    = 02H;
	CYAN     = 03H;
	RED      = 04H;
	MAGENTA  = 05H;
	BROWN    = 06H;
	WHITE    = 07H;
	GRAY     = 08H;
	LBLUE    = 09H;
	LGREEN   = 0AH;
	LCYAN    = 0BH;
	LRED     = 0CH;
	LMAGENTA = 0DH;
	YELLOW   = 0EH;
	BWHITE   = 0FH;
	
	// Characters
	SPACE = 20H;
	
	// GDT
	GDT_NULL = 0;
	GDT_CODE = 1;
	GDT_DATA = 2;
	
	GDT_SIZE = 3;
	
	// IDT
	IDT_SIZE = 256;
	
	// SYSCALL
	SYS_exit = 1;
	SYS_exitthread = 2;
	SYS_write = 4;
	
	// In/Out
	STDIN = 0;
	STDOUT = 1;
	
	// Tasks
	TASKS = 6;
	
TYPE
	Message = POINTER TO RECORD
		i: INTEGER;
		s: ARRAY 32 OF CHAR
	END;
	
	UINT32 = INTEGER;
	UINT16 = WCHAR;
	UINT8 = BYTE;
	
	SegmentDescriptor = RECORD [noalign]
		limit_low: UINT16;
		base_low: UINT16;
		base_middle, access_byte, limit_and_flags, base_high: UINT8
	END;
	
	GDT = ARRAY GDT_SIZE OF SegmentDescriptor;
	
	GateDescriptor = RECORD [noalign]
		handlerAddrLow, codeSeg: UINT16;
		reserved, access: UINT8;
		handlerAddrHi: UINT16
	END;

	IDT = ARRAY IDT_SIZE OF GateDescriptor;
	
	TableDesc = RECORD [noalign]
		size: UINT16;
		addr: UINT32
	END;
	
	CPU = RECORD [noalign]
		eax, ebx, ecx, edx: UINT32;
        esi, edi, ebp: UINT32;
        eip, error, cs, eflags, esp, ss: UINT32
	END;
	
	CPUState = POINTER TO CPU;
	
	Task = POINTER TO RECORD 
		inbox: ARRAY 10 OF Message;
		msgCount: INTEGER;
		handler: PROCEDURE(task: Task)
	END;
	
	TaskHandler = PROCEDURE(task: Task);
	
VAR
	cursor: RECORD
		line, column: INTEGER
	END;
	gdtCodeSeg: UINT16;
	masterCmd, masterData: Devices.Port;
	slaveCmd, slaveData: Devices.Port;
	keyboard: Devices.Keyboard;
	tasks: ARRAY TASKS OF Task;
	taskCount: INTEGER;
	kbdPressedQueue: ARRAY TASKS OF Task;
	kbdPressedQueueCount: INTEGER;
	uptime: INTEGER;

// ----------------------------SCREEN-------------------------------------------

PROCEDURE ClearScreen(bgColor: BYTE);
VAR
	x, y: INTEGER;
	offset: INTEGER;
BEGIN
	// clear screen
	offset := VideoMemoryAddr;
	FOR y:= 0 TO ScreenHeight - 1 DO
		FOR x:= 0 TO ScreenWidth - 1 DO
			SYSTEM.PUT16(offset, LSL(bgColor, 12) + SPACE);
			INC(offset, 2);
		END;
	END;
	
	cursor.line := 0;
	cursor.column := 0;

END ClearScreen;


PROCEDURE PrintLn();
BEGIN
	INC(cursor.line);
	cursor.column := 0;
	IF cursor.line = ScreenHeight THEN
		ClearScreen(BLACK);
		cursor.line := 0;
	END;
END PrintLn;


PROCEDURE Print(msg: ARRAY OF CHAR; fgColor, bgColor: BYTE);
VAR
	i: INTEGER;
	offset: INTEGER;
	ch: INTEGER;
	msgLen: INTEGER;
	c: CHAR;
BEGIN
	i := 0;
	msgLen := LENGTH(msg);
	offset := VideoMemoryAddr + (cursor.line * ScreenWidth * 2) + (cursor.column * 2);
	WHILE i < msgLen DO
		c := msg[i];
		CASE c OF
		|EOL:
			PrintLn();
			offset := VideoMemoryAddr + (cursor.line * ScreenWidth * 2) + (cursor.column * 2);
		ELSE
			ch :=  LSL(bgColor, 12) + LSL(fgColor, 8) + ORD(c);
			SYSTEM.PUT16(offset, ch);
			INC(offset, 2);
			INC(cursor.column);
		END;
		INC(i);
		
		IF cursor.column >= ScreenWidth THEN
			PrintLn();
		END;
	END;
END;


PROCEDURE PrintChar(ch: CHAR; fgColor, bgColor: BYTE);
VAR
	s: ARRAY 2 OF CHAR;
BEGIN
	s[0] := ch;
	Print(s, fgColor, bgColor);
END PrintChar;


PROCEDURE PrintHex8(value: BYTE; fgColor, bgColor: BYTE);
VAR
	str: ARRAY 3 OF CHAR;
	hex: ARRAY 17 OF CHAR;
	s, mask: SET;
	i: INTEGER;
BEGIN
    str := "00";
    hex := "0123456789ABCDEF";
    mask := BITS(0FH);
    
    s := BITS(LSR(value, 4)) * mask;
    i := ORD(s);
    str[0] := hex[i];
    
    s := BITS(value) * mask;
    i := ORD(s);
    str[1] := hex[i];
    
    Print(str, fgColor, bgColor);
END PrintHex8;


PROCEDURE PrintHex32(value: INTEGER; fgColor, bgColor: BYTE);
VAR
	value8: BYTE;
	i: INTEGER;
	addr: INTEGER;
BEGIN
	addr := SYSTEM.ADR(value);
	FOR i := 3 to 0 BY -1 DO
		SYSTEM.MOVE(addr + i, SYSTEM.ADR(value8), 1);
		PrintHex8(value8, fgColor, bgColor);
	END;
END PrintHex32;


PROCEDURE IntToStr(x: INTEGER; VAR str: ARRAY OF CHAR);
VAR
    i, a: INTEGER;
	zero: INTEGER;
BEGIN
	i := 0;
	a := x;
	zero := ORD('0');

	IF x < 0 THEN
		str[i] := "-";
		a := -a;
		x := -x;
		INC(i);
	END;

	REPEAT
		INC(i); a := a DIV 10
	UNTIL a = 0;

	str[i] := 0X;

	REPEAT
		DEC(i);
		str[i] := CHR(x MOD 10 + zero);
		x := x DIV 10
	UNTIL x = 0
END IntToStr;


PROCEDURE PrintInt(i: INTEGER; fgColor, bgColor: BYTE);
VAR
	str: ARRAY 32 OF CHAR;
BEGIN
	IntToStr(i, str);
	Print(str, fgColor, bgColor);
END PrintInt;


// ----------------------------KERNEL-------------------------------------------

// ------------------------KERNEL: BOOT-----------------------------------------

PROCEDURE ShowMultibootInfo(multiboot_structure: INTEGER; multiboot_magic: INTEGER);
VAR
	magic, mem_up, mem_low, boot_dev: INTEGER;
	
	PROCEDURE ShowMemInfo(mem: INTEGER);
	CONST
		KB = 1024;
	VAR
		mem_mkb: INTEGER;
	BEGIN
		PrintHex32(mem, CYAN, BLACK);
		Print(" => [", CYAN, BLACK);
		IF mem < KB THEN
			PrintInt(mem, CYAN, BLACK);
			Print(" Kbytes]", CYAN, BLACK);
		ELSE
			mem_mkb := mem DIV KB;
			PrintInt(mem_mkb, CYAN, BLACK);
			Print(" Mbytes]", CYAN, BLACK);
		END;
	END ShowMemInfo;

BEGIN
// https://www.gnu.org/software/grub/manual/multiboot/multiboot.html#Boot-information-format
	SYSTEM.GET32(multiboot_structure, magic);
	SYSTEM.GET32(multiboot_structure + 4, mem_low);
	SYSTEM.GET32(multiboot_structure + 8, mem_up);
	SYSTEM.GET32(multiboot_structure + 12, boot_dev);
	
	Print("--------------------------------------------------------------------------------", WHITE, BLACK);
	Print("multiboot_magic: ", BLUE, BLACK); PrintHex32(multiboot_magic, CYAN, BLACK); PrintLn();
	Print("multiboot_structure: ", BLUE, BLACK); PrintHex32(multiboot_structure, CYAN, BLACK); PrintLn();
	Print("multiboot_structure/magic: ", BLUE, BLACK); PrintHex32(magic, CYAN, BLACK); PrintLn();
	Print("multiboot_structure/mem_lower: ", BLUE, BLACK); ShowMemInfo(mem_low); PrintLn();
	Print("multiboot_structure/mem_upper: ", BLUE, BLACK); ShowMemInfo(mem_up); PrintLn();
	Print("multiboot_structure/boot_device: ", BLUE, BLACK); PrintHex32(boot_dev, CYAN, BLACK); PrintLn();
	Print("--------------------------------------------------------------------------------", WHITE, BLACK); 
	PrintLn();

END ShowMultibootInfo;


PROCEDURE [oberon] LoadGDT(addr: UINT32);
BEGIN
	SYSTEM.CODE(
		8bH, 45H, 08H,	(* mov    0x8(%ebp), %eax *)
		0FH, 01H, 10H	(* lgdtl  (%eax) *)
	);
END LoadGDT;


PROCEDURE [extern, "reload_segs"] ReloadSegments();


PROCEDURE InstallGDT(VAR gdt: GDT);
CONST
	SEGMENT_0CODE_TYPE  = 09AH;
	SEGMENT_0DATA_TYPE  = 092H;
	SEGMENT_FLAGS_PART = 00CH;

VAR
	gdtAddr: TableDesc;

	PROCEDURE NewSegmentDescriptor(VAR segment: SegmentDescriptor; base_address, limit: UINT32; access_byte, flags: UINT8);
	VAR
		s1, s2: SET;
	BEGIN
		s1 := BITS(base_address) * BITS(0FFFFH);
		SYSTEM.PUT16(SYSTEM.ADR(segment.base_low), ORD(s1));
		s1 := BITS(LSR(base_address, 16)) * BITS(0FFH);
		SYSTEM.PUT8(SYSTEM.ADR(segment.base_middle), ORD(s1));
		s1 := BITS(LSR(base_address, 24)) * BITS(0FFH);
		SYSTEM.PUT8(SYSTEM.ADR(segment.base_high), ORD(s1));
		
		s1 := BITS(limit) * BITS(0FFFFH);
		SYSTEM.PUT16(SYSTEM.ADR(segment.limit_low), ORD(s1));
		
		s1 := BITS(LSR(limit, 16)) * BITS(0FH);
		SYSTEM.PUT8(SYSTEM.ADR(segment.limit_and_flags), ORD(s1));
		
		s1 := BITS(segment.limit_and_flags);
		s2 := BITS(LSL(flags, 4)) * BITS(0F0H);
		s1 := s1 + s2;
		SYSTEM.PUT8(SYSTEM.ADR(segment.limit_and_flags), ORD(s1));
		
		segment.access_byte := access_byte;
	END;

BEGIN
	// segments
	NewSegmentDescriptor(gdt[GDT_NULL], 0, 0, 0, 0); // null
	NewSegmentDescriptor(gdt[GDT_CODE], 0, 0FFFFFH, SEGMENT_0CODE_TYPE, SEGMENT_FLAGS_PART); // kernel code
	NewSegmentDescriptor(gdt[GDT_DATA], 0, 0FFFFFH, SEGMENT_0DATA_TYPE, SEGMENT_FLAGS_PART); // kernel data
	
	
	// Load GDT
	SYSTEM.PUT32(SYSTEM.ADR(gdtAddr.addr), SYSTEM.ADR(gdt));
	SYSTEM.PUT16(SYSTEM.ADR(gdtAddr.size), SYSTEM.SIZE(GDT) - 1);
	
	LoadGDT(SYSTEM.ADR(gdtAddr));
	ReloadSegments();

END InstallGDT;


// ----------------------KERNEL: INTERRUPTS-------------------------------------
PROCEDURE NewGateDescriptor(VAR gd: GateDescriptor; codeSeg: UINT16; handler: UINT32; privLvl, _type: UINT8);
CONST 
	IDT_DESC_PRESENT = 080H;
VAR
	accessMask, presentMask, privMask, _typeMask: SET;
	s1: SET;
BEGIN
	s1 := BITS(handler) * BITS(0FFFFH);
	SYSTEM.PUT16(SYSTEM.ADR(gd.handlerAddrLow), ORD(s1));
	s1 := BITS(LSR(handler, 16)) * BITS(0FFFFH);
	SYSTEM.PUT16(SYSTEM.ADR(gd.handlerAddrHi), ORD(s1));
	gd.codeSeg := codeSeg;
	
	presentMask := BITS(IDT_DESC_PRESENT);
	privMask := BITS(LSL(ORD(BITS(privLvl) * {03H}), 5));
	_typeMask := BITS(_type);
	accessMask := presentMask + privMask + _typeMask;
	
	gd.access := ORD(accessMask);
	gd.reserved := 0;

END NewGateDescriptor;


PROCEDURE LoadIDT(addr: UINT32);
BEGIN
	SYSTEM.CODE(
		8bH, 45H, 08H,	(* mov    0x8(%ebp), %eax *)
		0FH, 01H, 18H	(* lidt  (%eax) *)
	);
END;


PROCEDURE [extern, "set_handlers"] SetHandlers(addr: UINT32);


PROCEDURE InstallIDT(VAR idt: IDT; VAR gdt: GDT);
CONST
	IDT_INTERRUPT_GATE = 0EH;
	HW_INTERRUPT_OFFSET = 20H;
	SYS_INTERRUPT_OFFSET = 080H;

VAR
	gdtCodeSegOffs: INTEGER;
	i: INTEGER;
	idtp: TableDesc;
	handlers: ARRAY 256 OF UINT32;

BEGIN
	
	SetHandlers(SYSTEM.ADR(handlers));
	
	gdtCodeSegOffs := SYSTEM.ADR(gdt[GDT_CODE]) - SYSTEM.ADR(gdt[GDT_NULL]);
	SYSTEM.PUT16(SYSTEM.ADR(gdtCodeSeg), gdtCodeSegOffs);
	
	// Exceptions
	FOR i := 00H TO 13H DO
		NewGateDescriptor(idt[i], gdtCodeSeg, handlers[i], 0, IDT_INTERRUPT_GATE);
	END;
	
	// Hardware interrupts
	FOR i := HW_INTERRUPT_OFFSET TO HW_INTERRUPT_OFFSET + 0FH DO
		NewGateDescriptor(idt[i], gdtCodeSeg, handlers[i], 0, IDT_INTERRUPT_GATE);
	END;
	
	// Syscalls
	FOR i := SYS_INTERRUPT_OFFSET TO SYS_INTERRUPT_OFFSET DO
		NewGateDescriptor(idt[i], gdtCodeSeg, handlers[i], 0, IDT_INTERRUPT_GATE);
	END;
	
	// Initialize PICs
	Devices.Write8(masterCmd, 011H);
	Devices.Write8(slaveCmd, 011H);
	
	Devices.Write8(masterData, HW_INTERRUPT_OFFSET);
	Devices.Write8(slaveData, HW_INTERRUPT_OFFSET + 8);
	
	Devices.Write8(masterData, 04H);
	Devices.Write8(slaveData, 02H);
	
	Devices.Write8(masterData, 01H);
	Devices.Write8(slaveData, 01H);
	
	Devices.Write8(masterData, 00H);
	Devices.Write8(slaveData, 00H);
	
	// Initialize keyboard
	Devices.InitKeyboard(keyboard);
	
	// Load IDT
	SYSTEM.PUT32(SYSTEM.ADR(idtp.addr), SYSTEM.ADR(idt));
	SYSTEM.PUT16(SYSTEM.ADR(idtp.size), SYSTEM.SIZE(IDT) - 1);
	LoadIDT(SYSTEM.ADR(idtp));
	
END;


PROCEDURE CreateDevices();
BEGIN
	Devices.NewPort(masterCmd, 020H);
	Devices.NewPort(masterData, 021H);
	Devices.NewPort(slaveCmd, 0A0H);
	Devices.NewPort(slaveData, 0A1H);
	Devices.NewKeyboard(keyboard);
END CreateDevices;


PROCEDURE DisableInterrupts();
BEGIN
	SYSTEM.CODE(0FAH); (* cli *)
END DisableInterrupts;


PROCEDURE EnableInterrupts();
BEGIN
	SYSTEM.CODE(0FBH); (* sti *)
END EnableInterrupts;


PROCEDURE kernelSetup*(multiboot_structure: INTEGER; multiboot_magic: INTEGER);
VAR
	gdt: GDT;
	idt: IDT;
BEGIN
	ClearScreen(BLACK);
	ShowMultibootInfo(multiboot_structure, multiboot_magic);

	CreateDevices();
	
	DisableInterrupts();
	
	InstallGDT(gdt);
	InstallIDT(idt, gdt);
	
	EnableInterrupts();
END;


PROCEDURE kernelPrint*(addr, size: INTEGER);
VAR
	msg: ARRAY 32 OF CHAR;
BEGIN
	SYSTEM.MOVE(addr, SYSTEM.ADR(msg), MIN(size, 32));
	Print(msg, WHITE, BLACK);
END kernelPrint;


PROCEDURE kernelPrintInt*(value: INTEGER);
BEGIN
	PrintHex32(value, WHITE, BLACK);
	PrintLn();
END kernelPrintInt;


PROCEDURE [extern, "_stop"] Halt();


PROCEDURE LogCPU(cpu: CPUState);


PROCEDURE LogHex32(label: ARRAY OF CHAR; value: UINT32; comma: BOOLEAN);
BEGIN
	Print(label, BLUE, WHITE); PrintHex32(value, BLUE, WHITE);
	IF comma THEN Print(", ", BLUE, WHITE); END;
END LogHex32;

BEGIN

	LogHex32("eax: ", cpu.eax, TRUE);
	LogHex32("ebx: ", cpu.ebx, TRUE);
	LogHex32("ecx: ", cpu.ecx, TRUE);
	LogHex32("edx: ", cpu.edx, TRUE);
	PrintLn();
	LogHex32("esi: ", cpu.esi, TRUE);
	LogHex32("edi: ", cpu.edi, TRUE);
	LogHex32("ebp: ", cpu.ebp, TRUE);
	PrintLn();
	
	LogHex32("error: ", cpu.error, TRUE);
	LogHex32("eip: ", cpu.eip, TRUE);
	LogHex32("cs: ", cpu.cs, TRUE);
	PrintLn();
	LogHex32("eflags: ", cpu.eflags, TRUE);
	LogHex32("esp: ", cpu.esp, TRUE);
	LogHex32("ss: ", cpu.ss, TRUE);
	PrintLn();
	
END LogCPU;


PROCEDURE Send(task: Task; msg: Message): BOOLEAN;
BEGIN
	IF task.msgCount < 10 THEN
		NEW(task.inbox[task.msgCount]);
		task.inbox[task.msgCount]^ := msg^;
		INC(task.msgCount);
	END;
	RETURN task.msgCount <= 10
END Send; 


PROCEDURE [oberon] kernelInterruptHandler*(interrupt: UINT8; esp: UINT32): UINT32;

CONST
	TIMER = 020H;
	KEYBOARD = 021H;
	SYSCALL = 0A0H;
	GPF = 00DH;
VAR
	keyEvt: Devices.KeyEvent;
	cpu: CPUState;
	addr: UINT32;
	i: INTEGER;
	msg: Message;
	task: Task;
BEGIN
	addr := esp;
	cpu := SYSTEM.VAL(addr, CPUState);

	CASE interrupt OF
	| TIMER: INC(uptime)
	| KEYBOARD:
		Devices.ReadKey(keyboard, keyEvt);
		IF (keyEvt.code # 0) & (keyEvt.status = Devices.KEY_PRESSED) THEN
			IF keyEvt.chr # 0X THEN
				FOR i := 0 TO kbdPressedQueueCount - 1 DO
					task := kbdPressedQueue[i];
					NEW(msg);
					msg.i := 1; // KeyEvent
					msg.s[0] := keyEvt.chr;
					IF ~ Send(task, msg) THEN
						Print("message not sent", RED, GREEN); PrintLn();
					END;
					DISPOSE(msg);
				END;
			END;
		END;
	| SYSCALL:
		CASE cpu.eax OF
		| SYS_exit: Halt();
		| SYS_exitthread: 
			IF cpu.eax # 0 THEN
				Print("[exitthread]", BROWN, YELLOW);
			END;
			Halt();
		| SYS_write:
			kernelPrint(cpu.ecx, cpu.edx);
		ELSE
			PrintLn(); 
			Print("Unknown syscall:", BROWN, YELLOW);
			PrintInt(cpu.eax, BROWN, YELLOW);
			Halt();
		END;
	| GPF:
		LogCPU(cpu);
		Halt()
	ELSE
		PrintLn();
		Print("UNHANDLED INTERRUPT: ", BLACK, MAGENTA); PrintHex8(interrupt, BLACK, MAGENTA);
		PrintLn();
		Halt();
	END;

	// Acknowledge the PICs for message received
	Devices.Write8(masterCmd, 020H);
	IF interrupt >= 28H THEN
		Devices.Write8(slaveCmd, 020H);
	END;
	
	RETURN esp
	
END kernelInterruptHandler;


// ----------------------------- USERSPACE -------------------------------------

PROCEDURE Subscribe(task: Task);
BEGIN
	kbdPressedQueue[kbdPressedQueueCount] := task;
	INC(kbdPressedQueueCount);
END Subscribe;


PROCEDURE NewTask(handler: TaskHandler);
VAR
	task: Task;
BEGIN
	NEW(task);
	task.handler := handler;
	tasks[taskCount] := task;
	INC(taskCount);
END NewTask;


PROCEDURE Process();
VAR
	i: INTEGER;
	task: Task;
BEGIN
	FOR i := 0 TO taskCount - 1 DO
		task := tasks[i];
		Subscribe(task);
		task.handler(task);
	END;
END Process;


PROCEDURE Wait();
BEGIN
	//SYSTEM.CODE(0F3H, 090H); // PAUSE
	SYSTEM.CODE(0F4H); // HLT
END Wait;


PROCEDURE NumberTaskHandler(task: Task);
CONST
	MAXINT = "2147483647";

VAR
	msg: Message;
	eom: BOOLEAN;
	str: ARRAY 10 OF CHAR;
	strCount: INTEGER;
	ch: CHAR;

PROCEDURE IsNumber(ch: CHAR): BOOLEAN;
CONST
	ZERO = ORD('0');
	NINE = ORD('9');
BEGIN
	RETURN (ORD(ch) >= ZERO) & (ORD(ch) <= NINE)
END IsNumber;


PROCEDURE GreaterThan(s1, s2: ARRAY OF CHAR): BOOLEAN;
VAR
	i, len: INTEGER;
	ch1, ch2: CHAR;
	greater: BOOLEAN;
BEGIN
	len := LENGTH(s1);
	IF len = LENGTH(s2) THEN
		FOR i := 0 TO len - 1 DO
			ch1 := s1[i]; ch2 := s2[i];
			IF ORD(ch1) > ORD(ch2) THEN
				greater := TRUE;
				i := len;
			END;
		END
	ELSE
		greater := FALSE;
	END;
	
	RETURN greater
END GreaterThan;


BEGIN
	PrintLn();
	Print("Enter a number: ", GREEN, BLACK);
	WHILE ~ eom & (strCount < 10) DO
		Wait();
		IF task.msgCount > 0 THEN
			msg := task.inbox[task.msgCount-1];
			ch := msg.s[0];
			eom := ch = EOL;
			IF ~ eom & IsNumber(ch) THEN
				Print(msg.s, GREEN, BLACK);
				str[strCount] := msg.s[0];
				INC(strCount);
			END;
			DISPOSE(msg);
			DEC(task.msgCount);
		END;
	END;
	
	PrintLn();
	IF GreaterThan(str, MAXINT) THEN
		Print("Number exceeded max integer: ", GREEN, BLACK); Print(MAXINT, GREEN, BLACK);
	ELSE
		Print("The number is: ", GREEN, BLACK); Print(str, GREEN, BLACK);
	END;
	
	PrintLn();
END NumberTaskHandler;


BEGIN
	Print("Booting OS...", BLUE, BLACK);
	NewTask(NumberTaskHandler);
	NewTask(NumberTaskHandler);
	Process();
	// SYS_exit
END Kernel.
