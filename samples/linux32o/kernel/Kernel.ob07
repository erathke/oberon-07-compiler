MODULE Kernel;
IMPORT SYSTEM;

CONST 
	VideoMemoryAddr = 0b8000H;
	ScreenWidth = 80;
	ScreenHeight = 25;
	
	// Colors
	BLACK    = 00H;
	BLUE     = 01H;
	GREEN    = 02H;
	CYAN     = 03H;
	RED      = 04H;
	MAGENTA  = 05H;
	BROWN    = 06H;
	WHITE    = 07H;
	GRAY     = 08H;
	LBLUE    = 09H;
	LGREEN   = 0AH;
	LCYAN    = 0BH;
	LRED     = 0CH;
	LMAGENTA = 0DH;
	YELLOW   = 0EH;
	BWHITE   = 0FH;
	
	// Characters
	SPACE = 20H;
	
	// GDT
	GDT_NULL = 0;
	GDT_CODE = 1;
	GDT_DATA = 2;
	
	GDT_SIZE = 3;
	
	// IDT
	IDT_SIZE = 256;
	
TYPE
	Message = POINTER TO RECORD
		i: INTEGER;
		s: ARRAY 32 OF CHAR
	END;
	
	UINT32 = INTEGER;
	UINT16 = WCHAR;
	UINT8 = BYTE;
	
	
	SegmentDescriptor = RECORD [noalign]
		limit_low: UINT16;
		base_low: UINT16;
		base_middle, access_byte, limit_and_flags, base_high: UINT8
	END;
	
	GDT = ARRAY GDT_SIZE OF SegmentDescriptor;
	
	
	GDTTableDesc = RECORD [noalign]
		size: UINT16;
		addr: UINT32
	END;
	
	GateDescriptor = RECORD [noalign]
		handlerAddrLow, gdtCodeSeg: UINT16;
		reserved, access: UINT8;
		handlerAddrHi: UINT16
	END;

	IDT = ARRAY IDT_SIZE OF GateDescriptor;
	
	InterruptHandler = PROCEDURE;
	
	InterruptTableDesc = RECORD [noalign]
		size: UINT16;
		addr: UINT32
	END;
	
VAR
	cursor: RECORD
		line, column: INTEGER
	END;

// ----------------------------SCREEN-------------------------------------------

PROCEDURE ClearScreen(bgColor: BYTE);
VAR
	x, y: INTEGER;
	offset: INTEGER;
BEGIN
	// clear screen
	offset := VideoMemoryAddr;
	FOR y:= 0 TO ScreenHeight - 1 DO
		FOR x:= 0 TO ScreenWidth - 1 DO
			SYSTEM.PUT16(offset, LSL(bgColor, 12) + SPACE);
			INC(offset, 2);
		END;
	END;
	
	cursor.line := 0;
	cursor.column := 0;

END ClearScreen;


PROCEDURE PrintLn();
BEGIN
	INC(cursor.line);
	cursor.column := 0;
	IF cursor.line = ScreenHeight THEN
		ClearScreen(BLACK);
		cursor.line := 0;
	END;
END PrintLn;


PROCEDURE Print(msg: ARRAY OF CHAR; fgColor, bgColor: BYTE);
VAR
	i: INTEGER;
	offset: INTEGER;
	ch: INTEGER;
	msgLen: INTEGER;
BEGIN
	i := 0;
	msgLen := LENGTH(msg);
	offset := VideoMemoryAddr + (cursor.line * ScreenWidth * 2) + (cursor.column * 2);
	WHILE i < msgLen DO
		ch :=  LSL(bgColor, 12) + LSL(fgColor, 8) + ORD(msg[i]);
		SYSTEM.PUT16(offset, ch);
		INC(i); INC(offset, 2);
	END;
	
	cursor.column := cursor.column + i;
	IF cursor.column >= ScreenWidth THEN
		PrintLn();
	END;
	
END;


PROCEDURE PrintHex8(value: BYTE; fgColor, bgColor: BYTE);
VAR
	str: ARRAY 3 OF CHAR;
	hex: ARRAY 17 OF CHAR;
	s, mask: SET;
	i: INTEGER;
BEGIN
    str := "00";
    hex := "0123456789ABCDEF";
    mask := BITS(0FH);
    
    s := BITS(LSR(value, 4)) * mask;
    i := ORD(s);
    str[0] := hex[i];
    
    s := BITS(value) * mask;
    i := ORD(s);
    str[1] := hex[i];
    
    Print(str, fgColor, bgColor);
END PrintHex8;


PROCEDURE PrintHex32(value: INTEGER; fgColor, bgColor: BYTE);
VAR
	value8: BYTE;
	i: INTEGER;
	addr: INTEGER;
BEGIN
	addr := SYSTEM.ADR(value);
	FOR i := 3 to 0 BY -1 DO
		SYSTEM.MOVE(addr + i, SYSTEM.ADR(value8), 1);
		PrintHex8(value8, fgColor, bgColor);
	END;
END PrintHex32;


PROCEDURE IntToStr (x: INTEGER; VAR str: ARRAY OF CHAR);
VAR
    i, a: INTEGER;
	zero: INTEGER;
BEGIN
	i := 0;
	a := x;
	zero := ORD('0');

	IF x < 0 THEN
		str[i] := "-";
		a := -a;
		x := -x;
		INC(i);
	END;

	REPEAT
		INC(i); a := a DIV 10
	UNTIL a = 0;

	str[i] := 0X;

	REPEAT
		DEC(i);
		str[i] := CHR(x MOD 10 + zero);
		x := x DIV 10
	UNTIL x = 0
END IntToStr;


PROCEDURE PrintInt(i: INTEGER; fgColor, bgColor: BYTE);
VAR
	str: ARRAY 32 OF CHAR;
BEGIN
	IntToStr(i, str);
	Print(str, fgColor, bgColor);
END PrintInt;


// ----------------------------KERNEL-------------------------------------------

// ------------------------KERNEL: PORTS----------------------------------------
PROCEDURE Write32(port, value: UINT32);
BEGIN
	// __asm__ volatile("outl %0, %1" : : "a"(_data), "Nd" (_port));
END Write32;


PROCEDURE Write16(port: UINT32; value: UINT16);
BEGIN
	// __asm__ volatile("outw %0, %1" : : "a" (_data), "Nd" (_port));
END Write16;


PROCEDURE [oberon] Write8(port: UINT32; value: UINT8);
BEGIN
	SYSTEM.CODE(66H, 8BH, 55H, 08H, (* mov    0x8(%ebp),%dx *)
		8AH, 45H, 0CH,			(* mov    0xc(%ebp),%al *)
		0EEH                	(* out    %al,(%dx) *)
	);             	
END Write8;


PROCEDURE Read32(port: UINT32; VAR value: UINT32);
BEGIN
	//  __asm__ volatile("inl %1, %0" : "=a" (result) : "Nd" (_port));
END Read32;


PROCEDURE Read16(port: UINT32; VAR value: UINT16);
BEGIN
	// __asm__ volatile("inw %1, %0" : "=a" (result) : "Nd" (_port));
END Read16;


PROCEDURE Read8(port: UINT32; VAR value: UINT8);
BEGIN
	//  __asm__ volatile("inb %1, %0" : "=a" (result) : "Nd" (_port));
END Read8;


// ------------------------KERNEL: BOOT-----------------------------------------
PROCEDURE Process(steps: INTEGER);
VAR
	i, j: INTEGER;
	msg: Message;
BEGIN
	FOR i := 0 to steps DO
		NEW(msg);
		msg.s := ".";
		Print(msg.s, LGREEN, BLACK);
		FOR j := 0 TO 999999 DO END;
		DISPOSE(msg);
	END;
END Process;


PROCEDURE ShowMultibootInfo*(multiboot_structure: INTEGER; multiboot_magic: INTEGER);
VAR
	magic, mem_up, mem_low, boot_dev: INTEGER;
	
	PROCEDURE ShowMemInfo(mem: INTEGER);
	CONST
		KB = 1024;
	VAR
		mem_mkb: INTEGER;
	BEGIN
		PrintHex32(mem, CYAN, BLACK);
		Print(" => [", CYAN, BLACK);
		IF mem < KB THEN
			PrintInt(mem, CYAN, BLACK);
			Print(" Kbytes]", CYAN, BLACK);
		ELSE
			mem_mkb := mem DIV KB;
			PrintInt(mem_mkb, CYAN, BLACK);
			Print(" Mbytes]", CYAN, BLACK);
		END;
	END ShowMemInfo;

BEGIN
// https://www.gnu.org/software/grub/manual/multiboot/multiboot.html#Boot-information-format
	SYSTEM.GET32(multiboot_structure, magic);
	SYSTEM.GET32(multiboot_structure + 4, mem_low);
	SYSTEM.GET32(multiboot_structure + 8, mem_up);
	SYSTEM.GET32(multiboot_structure + 12, boot_dev);
	
	Print("--------------------------------------------------------------------------------", WHITE, BLACK);
	Print("multiboot_magic: ", BLUE, BLACK); PrintHex32(multiboot_magic, CYAN, BLACK); PrintLn();
	Print("multiboot_structure: ", BLUE, BLACK); PrintHex32(multiboot_structure, CYAN, BLACK); PrintLn();
	Print("multiboot_structure/magic: ", BLUE, BLACK); PrintHex32(magic, CYAN, BLACK); PrintLn();
	Print("multiboot_structure/mem_lower: ", BLUE, BLACK); ShowMemInfo(mem_low); PrintLn();
	Print("multiboot_structure/mem_upper: ", BLUE, BLACK); ShowMemInfo(mem_up); PrintLn();
	Print("multiboot_structure/boot_device: ", BLUE, BLACK); PrintHex32(boot_dev, CYAN, BLACK); PrintLn();
	Print("--------------------------------------------------------------------------------", WHITE, BLACK); 
	PrintLn();

END ShowMultibootInfo;


PROCEDURE [oberon] LoadGDT(addr: UINT32);
BEGIN
	SYSTEM.CODE(
		8bH, 45H, 08H,	(* mov    0x8(%ebp), %eax *)
		0FH, 01H, 10H	(* lgdtl  (%eax) *)
	);
END LoadGDT;


PROCEDURE [extern, "reload_segs"] ReloadSegments();


PROCEDURE InstallGDT(VAR gdt: GDT);
CONST
	SEGMENT_CODE_TYPE  = 09AH;
	SEGMENT_DATA_TYPE  = 092H;
	SEGMENT_FLAGS_PART = 00CH;

VAR
	gdtAddr: GDTTableDesc;

	PROCEDURE NewSegmentDescriptor(VAR segment: SegmentDescriptor; base_address, limit: UINT32; access_byte, flags: UINT8);
	VAR
		s1, s2: SET;
	BEGIN
		s1 := BITS(base_address) * BITS(0FFFFH);
		SYSTEM.PUT16(SYSTEM.ADR(segment.base_low), ORD(s1));
		s1 := BITS(LSR(base_address, 16)) * BITS(0FFH);
		SYSTEM.PUT8(SYSTEM.ADR(segment.base_middle), ORD(s1));
		s1 := BITS(LSR(base_address, 24)) * BITS(0FFH);
		SYSTEM.PUT8(SYSTEM.ADR(segment.base_high), ORD(s1));
		
		s1 := BITS(limit) * BITS(0FFFFH);
		SYSTEM.PUT16(SYSTEM.ADR(segment.limit_low), ORD(s1));
		
		s1 := BITS(LSR(limit, 16)) * BITS(0FH);
		SYSTEM.PUT8(SYSTEM.ADR(segment.limit_and_flags), ORD(s1));
		
		s1 := BITS(segment.limit_and_flags);
		s2 := BITS(LSL(flags, 4)) * BITS(0F0H);
		s1 := s1 + s2;
		SYSTEM.PUT8(SYSTEM.ADR(segment.limit_and_flags), ORD(s1));
		
		segment.access_byte := access_byte;
	END;

BEGIN
	// segments
	NewSegmentDescriptor(gdt[GDT_NULL], 0, 0, 0, 0); // null
	NewSegmentDescriptor(gdt[GDT_CODE], 0, 0FFFFFH, SEGMENT_CODE_TYPE, SEGMENT_FLAGS_PART); // code
	NewSegmentDescriptor(gdt[GDT_DATA], 0, 0FFFFFH, SEGMENT_DATA_TYPE, SEGMENT_FLAGS_PART); // data
	
	// Load GDT
	SYSTEM.PUT32(SYSTEM.ADR(gdtAddr.addr), SYSTEM.ADR(gdt));
	SYSTEM.PUT16(SYSTEM.ADR(gdtAddr.size), SYSTEM.SIZE(GDT) - 1);
	
	LoadGDT(SYSTEM.ADR(gdtAddr));
	ReloadSegments();

END InstallGDT;


// ----------------------KERNEL: INTERRUPTS-------------------------------------
PROCEDURE NewGateDescriptor(VAR gd: GateDescriptor; gdtCodeSeg: UINT16; handlerAddr: UINT32; privilegeLvl, _type: UINT8);
CONST 
	IDT_DESC_PRESENT = 080H;
VAR
	accessMask, presentMask, privMask, _typeMask: SET;
	s1: SET;
BEGIN
	s1 := BITS(handlerAddr) * BITS(0FFFFH);
	SYSTEM.PUT16(SYSTEM.ADR(gd.handlerAddrLow), ORD(s1));
	s1 := BITS(LSR(handlerAddr, 16)) * BITS(0FFFFH);
	SYSTEM.PUT16(SYSTEM.ADR(gd.handlerAddrHi), ORD(s1));
	gd.gdtCodeSeg := gdtCodeSeg;
	
	presentMask := BITS(IDT_DESC_PRESENT);
	privMask := BITS(LSL(ORD(BITS(privilegeLvl) * {03H}), 5));
	_typeMask := BITS(_type);
	accessMask := presentMask + privMask + _typeMask;
	
	gd.access := ORD(accessMask);
	gd.reserved := 0;

END NewGateDescriptor;


PROCEDURE LoadIDT(addr: UINT32);
BEGIN
	SYSTEM.CODE(
		8bH, 45H, 08H,	(* mov    0x8(%ebp), %eax *)
		0FH, 01H, 18H	(* lidt  (%eax) *)
	);
END;


PROCEDURE [extern, "set_handlers"] SetHandlers(addr: UINT32);


PROCEDURE InstallIDT(VAR idt: IDT; VAR gdt: GDT);
CONST
	IDT_INTERRUPT_GATE = 0EH;
	HW_INTERRUPT_OFFSET = 20H;
	SYS_INTERRUPT_OFFSET = 080H;

VAR
	gdtCodeSeg: UINT16;
	gdtCodeSegOffs: INTEGER;
	i: INTEGER;
	idtp: InterruptTableDesc;
	masterPortData, slavePortData: UINT32;
	masterPortCmd, slavePortCmd: UINT32;
	handlers: ARRAY 256 OF UINT32;

BEGIN
	gdtCodeSegOffs := SYSTEM.ADR(gdt[GDT_CODE]) - SYSTEM.ADR(gdt[GDT_NULL]);
	SYSTEM.PUT16(SYSTEM.ADR(gdtCodeSeg), gdtCodeSegOffs);
	
	SetHandlers(SYSTEM.ADR(handlers));
	
	// Exceptions
	FOR i := 00H TO 13H DO
		NewGateDescriptor(idt[i], gdtCodeSeg, handlers[i], 0, IDT_INTERRUPT_GATE);
	END;
	
	// Hardware interrupts
	FOR i := HW_INTERRUPT_OFFSET TO HW_INTERRUPT_OFFSET + 0FH DO
		NewGateDescriptor(idt[i], gdtCodeSeg, handlers[i], 0, IDT_INTERRUPT_GATE);
	END;
	
	// Syscall
	FOR i := SYS_INTERRUPT_OFFSET TO SYS_INTERRUPT_OFFSET DO
		NewGateDescriptor(idt[i], gdtCodeSeg, handlers[i], 0, IDT_INTERRUPT_GATE);
	END;
	
	
	// Initialize PICs
	masterPortCmd := 020H;
	masterPortData := 021H;
	slavePortCmd := 0A0H;
	slavePortData := 0A1H;
	
	Write8(masterPortCmd, 011H);
	Write8(slavePortCmd, 011H);
	
	Write8(masterPortData, HW_INTERRUPT_OFFSET);
	Write8(slavePortData, HW_INTERRUPT_OFFSET + 8);
	
	Write8(masterPortData, 04H);
	Write8(slavePortData, 02H);
	
	Write8(masterPortData, 01H);
	Write8(slavePortData, 01H);
	
	Write8(masterPortData, 00H);
	Write8(slavePortData, 00H);
	
	
	// Load IDT
	SYSTEM.PUT32(SYSTEM.ADR(idtp.addr), SYSTEM.ADR(idt));
	SYSTEM.PUT16(SYSTEM.ADR(idtp.size), SYSTEM.SIZE(IDT) - 1);
	
	LoadIDT(SYSTEM.ADR(idtp));
	
END;


PROCEDURE kernelMain*(multiboot_structure: INTEGER; multiboot_magic: INTEGER);
VAR
	gdt: GDT;
	idt: IDT;
BEGIN
	ClearScreen(BLACK);
	ShowMultibootInfo(multiboot_structure, multiboot_magic);
	
	SYSTEM.CODE(0FAH); (* cli *)
	InstallGDT(gdt);
	InstallIDT(idt, gdt);
	SYSTEM.CODE(0FBH); (* sti *)
	
	Print("Booting OS...", BLUE, BLACK);
	Process(100); PrintHex8(22, YELLOW, BROWN); PrintLn();
	WHILE TRUE DO END;
END;


PROCEDURE kernelPrint*(addr, size: INTEGER);
VAR
	msg: ARRAY 32 OF CHAR;
BEGIN
	SYSTEM.MOVE(addr, SYSTEM.ADR(msg), MIN(size, 32));
	Print(msg, WHITE, BLACK);
END kernelPrint;


PROCEDURE kernelPrintInt*(value: INTEGER);
BEGIN
	PrintHex32(value, WHITE, BLACK);
	PrintLn();
END kernelPrintInt;


PROCEDURE [oberon] kernelInterruptHandler*(interrupt: UINT8);
CONST
	TIMER = 020H;
	KEYBOARD = 021H;
BEGIN

	CASE interrupt OF
	| TIMER: // does nothing for now
	| KEYBOARD: // does nothing for now
	ELSE
		PrintLn();
		Print("UNHANDLED INTERRUPT: ", BLACK, MAGENTA); PrintHex8(interrupt, BLACK, MAGENTA);
		PrintLn();
	END;

	// Acknowledge the PICs to message received
	Write8(020H, 020H);
	IF interrupt >= 28H THEN
		Write8(0A0H, 020H);
	END;
	
	
END kernelInterruptHandler;


END Kernel.
